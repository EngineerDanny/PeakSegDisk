---
title: "Usage example"
author: "Toby Dylan Hocking"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Welcome to PeakSegDisk, an R package for optimal peak
detection in very large sequence count data. 

*** Write the file yourself

```{r}
sim.seg <- function(seg.mean, size.mean=15){
  seg.size <- rpois(1, size.mean)
  rpois(seg.size, seg.mean)
}
set.seed(1)
seg.mean.vec <- c(1.5, 3.5, 0.5, 4.5, 2.5)
z.list <- lapply(seg.mean.vec, sim.seg)
z.rep.vec <- unlist(z.list)
library(ggplot2)
count.df <- data.frame(
  position=seq_along(z.rep.vec),
  count=z.rep.vec)
gg.count <- ggplot()+
  geom_point(aes(
    position, count),
    shape=1,
    data=count.df)
gg.count
```

The true changepoints are shown below.

```{r}
n.segs <- length(seg.mean.vec)
seg.size.vec <- sapply(z.list, length)
seg.end.vec <- cumsum(seg.size.vec)
change.vec <- seg.end.vec[-n.segs]+0.5
change.df <- data.frame(
  changepoint=change.vec)
gg.change <- gg.count+
  geom_vline(aes(
    xintercept=changepoint),
    data=change.df)
gg.change
```

To use these data with PeakSegDisk they must be convert to run-length
encoding, i.e. the segments shown below.

```{r}
z.rle.vec <- rle(z.rep.vec)
chromEnd <- cumsum(z.rle.vec$lengths)
coverage.df <- data.frame(
  chrom="chrUnknown",
  chromStart=c(0L, chromEnd[-length(chromEnd)]),
  chromEnd,
  count=z.rle.vec$values)
gg.rle <- gg.change+
  geom_segment(aes(
    chromStart+0.5, count, xend=chromEnd+0.5, yend=count),
    data=coverage.df)
gg.rle
```

The data must then be saved to a
chrUnknown-start-end/coverage.bedGraph file. The file system is used
as the interface in order to support very large data sets, with very
little memory usage.

```{r}
data.dir <- file.path(
  tempdir(),
  with(coverage.df, sprintf(
    "%s-%d-%d", chrom[1], min(chromStart), max(chromEnd))))
dir.create(data.dir, showWarnings=FALSE)
coverage.bedGraph <- file.path(data.dir, "coverage.bedGraph")
write.table(
  coverage.df, coverage.bedGraph,
  sep="\t", row.names=FALSE, col.names=FALSE)
```

The next step is to run the main solver, 

```{r}
(fit <- PeakSegDisk::problem.PeakSegFPOP(data.dir, "10.5"))
```

The model output list above includes `fit$segments`, a data table with
one row for each segment mean, and `fit$loss`, a data table with one
row that reports the model meta-data. Of interest are:

* `penalty`, the user-provided penalty value,
* `segments`, the number of segments,
* `peaks`, the number of peaks (even-numbered segments),
* `bases`, the number of data points in repetitive form (not run-length encoding),
* `bedGraph.lines`, the number of data points in run-length encoding form,
* `mean.pen.cost`, the optimal mean loss plus penalty*peaks,
* `total.loss`, the optimal total Poisson loss over all data points, 
* `equality.constraints`, the number of adjacent segment means that are equal in the optimal solution,
* `megabytes`, the storage space on disk used by the solver,
* `seconds`, the amount of time used by the solver,
* `mean.intervals`, `max.intervals`, statistics over all intervals
  (candidate changepoints) computed by the functional pruning
  algorithm, useful for analyzing computational complexity, which is
  linear in the number of intervals.

```{r}
gg.rle+
  geom_segment(aes(
    chromStart+0.5, mean, xend=chromEnd+0.5, yend=mean),
    color="green",
    data=fit$segments)
```

*** Helper functions

When data is already in memory in R, there are helper functions that
do the above procedure for you:

```{r}
fit <- PeakSegDisk::PeakSegFPOP_df(coverage.df, 10.5)
fit <- PeakSegDisk::PeakSegFPOP_vec(z.rep.vec, 10.5)
```




